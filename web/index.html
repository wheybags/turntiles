<!DOCTYPE html>
<html lang="en">
<head>
    <title>Orientile</title>

    <style>
        body, html {
            padding: 0;
            margin: 0;
        }

        #game_canvas {
            background-color: rgb(230, 230, 230);
            width: 100vw;
            height: 100vh;
            padding: 0;
            margin: 0;
            position: absolute;
            left: 0;
            top: 0;
        }
    </style>
</head>
<body>

<canvas id="game_canvas" width="800" height="800"></canvas>

<script>

    // https://stackoverflow.com/a/12646864
    function shuffleArray(array) {
        for (var i = array.length - 1; i > 0; i--) {
            var j = Math.floor(Math.random() * (i + 1));
            var temp = array[i];
            array[i] = array[j];
            array[j] = temp;
        }
    }

    function parseGameString(gameString)
    {
        const board = [];
        const tiles = [];

        let i = 0;
        let acc = "";

        let boardTilesW = null;
        for (; i < gameString.length; i++)
        {
            if (gameString[i] === 'x')
            {
                boardTilesW = parseInt(acc);
                acc = "";
                break;
            }
            else
            {
                console.assert(gameString[i].match(/[0-9]/i));
                acc += gameString[i];
            }
        }

        console.assert(gameString[i] === 'x');
        i++;

        let boardTilesH = null;
        for (; i < gameString.length; i++)
        {
            if (!gameString[i].match(/[0-9]/i))
            {
                boardTilesH = parseInt(acc);
                acc = "";
                break;
            }
            else
            {
                acc += gameString[i];
            }
        }

        const solutionBoard = [];
        for (let y = 0; y < boardTilesH; y++)
        {
            const row = [];
            solutionBoard.push(row);
            for (let x = 0; x < boardTilesW; x++)
            {
                const letter = gameString[i];
                const direction = gameString[i + 1];
                row.push(letter+direction);
                i += 2;
            }
        }

        for (let y = 0; y < boardTilesH; y++)
        {
            const row = [];
            board.push(row);
            for (let x = 0; x < boardTilesW; x++)
            {
                const letter = solutionBoard[y][x][0];
                const direction = solutionBoard[y][x][1];

                if (letter !== '-')
                {
                    tiles.push({
                        x: 0,
                        y: 0,
                        letter: letter,
                        direction: direction,
                        boardPos: null,
                    })
                }

                let pointAtX = x;
                let pointAtY = y;
                if (direction === "<")
                    pointAtX--;
                else if (direction === ">")
                    pointAtX++;
                else if (direction === "^")
                    pointAtY--;
                else if (direction === "v")
                    pointAtY++;

                let pointAt = [pointAtY, pointAtX];
                if (!(pointAtX >= 0 && pointAtX < boardTilesW && pointAtY >= 0 && pointAtY < boardTilesH))
                    pointAt = null;

                row.push({
                    direction: direction,
                    tile: null,
                    pointedAtByOtherPos: [],
                    pointAt: pointAt,
                    confirmed: false,
                    pos: [y,x],
                })
            }
        }

        for (let y = 0; y < boardTilesH; y++)
        {
            for (let x = 0; x < boardTilesW; x++)
            {
                const boardPos = board[y][x];
                if (boardPos.pointAt !== null)
                    board[boardPos.pointAt[0]][boardPos.pointAt[1]].pointedAtByOtherPos.push([y,x]);
            }
        }

        shuffleArray(tiles);

        return [board, tiles, solutionBoard];
    }

    function randomScatterTiles(tileSpawnTop, tileSpawnBottom, tileSpawnLeft, tileSpawnRight)
    {
        for (const tile of tiles)
        {
            tile.x = tileSpawnLeft + (tileSpawnRight-tileSpawnLeft)/2 + Math.random();
            tile.y = tileSpawnTop + (tileSpawnBottom-tileSpawnTop)/2 + Math.random();
        }

        // a few iterations of reverse flocking to push tiles apart
        for (let i = 0; i < 500; i++)
        {
            for (const tile of tiles)
            {
                let dir = [Math.random()*2-1,Math.random()*2-1];

                for (const other of tiles)
                {
                    if (other === tile)
                        continue;

                    const v = [tile.x - other.x, tile.y - other.y];

                    if (Math.abs(v[0]) > 0.000001 || Math.abs(v[1]) > 0.000001)
                    {
                        let mag = Math.sqrt(v[0] * v[0] + v[1] * v[1]);
                        v[0] = v[0]/mag; v[1] = v[1]/mag; // v = normalize(v);

                        let alpha = smoothstep(0, TILE_SIZE*2, mag);
                        alpha = 1.0 - alpha;

                        dir[0] += v[0] * alpha;
                        dir[1] += v[1] * alpha;
                    }
                }

                tile.x += dir[0];
                tile.y += dir[1];

                if (tile.x < tileSpawnLeft)
                    tile.x = tileSpawnLeft;
                if (tile.x > tileSpawnRight)
                    tile.x = tileSpawnRight;
                if (tile.y < tileSpawnTop)
                    tile.y = tileSpawnTop;
                if (tile.y > tileSpawnBottom)
                    tile.y = tileSpawnBottom;
            }
        }
    }

    function randomIntFromInterval(min, max) { // min and max included
        return Math.floor(Math.random() * (max - min + 1) + min);
    }

    function smoothstep(edge0, edge1, x) {
        const t = Math.min(Math.max((x - edge0) / (edge1 - edge0), 0), 1);
        return t * t * (3 - 2 * t);
    }


    const gameString = "4x4 y<rvd<-x l^y<h<s< l^o<o>uv a^f^s^p>".replace(/ /g,'');
    //const gameString = "4x4 rvbvev-x uvivd<hv lvb<b<o< eva^c<g^".replace(/ /g,'');


    const gameCanvas = document.getElementById("game_canvas");
    gameCanvas.width = window.innerWidth * window.devicePixelRatio;
    gameCanvas.height = window.innerHeight * window.devicePixelRatio;
    const ctx = gameCanvas.getContext("2d");



    const scale = window.devicePixelRatio;

    let TILE_SIZE;
    let TILE_RADIUS;
    let TILE_BORDER;
    let ARROW_WIDE;
    let ARROW_LONG;
    let TILE_TEXT_SIZE;
    let BOARD_PAD;
    let TILE_SPAWN_PAD;

    function rescale()
    {
        TILE_SIZE = 50 * scale;
        TILE_RADIUS = 8 * scale;
        TILE_BORDER = 5 * scale;
        ARROW_WIDE = 10 * scale;
        ARROW_LONG = 10 * scale;
        TILE_TEXT_SIZE = 30 * scale;
        BOARD_PAD = 15 * scale;
        TILE_SPAWN_PAD = TILE_SIZE/2 + BOARD_PAD;
    }

    rescale();

    const BOARD_COLOR = "#aaaaa3";
    const BOARD_SLOT_COLOR = "#efefe6";
    const BOARD_CONNECT_COLOR = "#60605c";
    const BOARD_CONFIRMED_COLOR = "#346c17";
    const TILE_COLOR = "#5a594e";
    const TILE_CONFIRMED_COLOR = BOARD_CONFIRMED_COLOR;
    const TILE_BORDER_COLOR = "black";//"#3d3d35";


    const [board, tiles, solutionBoard] = parseGameString(gameString);
    const boardTilesW = board[0].length;
    const boardTilesH = board.length;


    const boardW = boardTilesW*TILE_SIZE + (boardTilesW+1)*BOARD_PAD;
    const boardH = boardTilesH*TILE_SIZE + (boardTilesH+1)*BOARD_PAD;

    const boardX = Math.round(gameCanvas.width/2 - boardW/2);
    const boardY = 50;


    // const text = ctx.measureText("M");
    // console.log(text);

    {
        let tileSpawnTop = boardY + boardH + TILE_SPAWN_PAD;
        let tileSpawnBottom = Math.min(tileSpawnTop + boardH, gameCanvas.height - TILE_SPAWN_PAD);

        if (tileSpawnBottom < gameCanvas.height - TILE_SPAWN_PAD)
        {
            tileSpawnTop += TILE_SPAWN_PAD;
            tileSpawnBottom += TILE_SPAWN_PAD;
        }
        const tileSpawnLeft = Math.max(TILE_SPAWN_PAD, boardX - TILE_SIZE * 2);
        const tileSpawnRight = Math.min(gameCanvas.width - TILE_SPAWN_PAD, boardX + boardW + TILE_SIZE * 2);

        randomScatterTiles(tileSpawnTop, tileSpawnBottom, tileSpawnLeft, tileSpawnRight);
    }



    let selectedTile = null;
    let snappedBoardPos = null;
    let selectOffsetX = null;
    let selectOffsetY = null;

    function renderTiles()
    {
        for (const tile of tiles)
        {
            let color = TILE_COLOR;
            if (tile.boardPos && tile.boardPos.confirmed)
                color = TILE_CONFIRMED_COLOR;

            ctx.beginPath();
            ctx.roundRect(tile.x-TILE_SIZE/2, tile.y-TILE_SIZE/2, TILE_SIZE, TILE_SIZE, [TILE_RADIUS]);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = TILE_BORDER_COLOR
            ctx.lineWidth = TILE_BORDER;
            ctx.stroke();

            const rotateDegrees = {">": 0, "v": 90, "<": 180, "^": 270}[tile.direction]

            ctx.translate(tile.x, tile.y);
            ctx.rotate(rotateDegrees * Math.PI / 180);
            ctx.beginPath();
                ctx.moveTo(TILE_SIZE/2, -ARROW_WIDE);
                ctx.lineTo(TILE_SIZE/2, +ARROW_WIDE);
                ctx.lineTo(TILE_SIZE/2+ARROW_LONG, 0);
                ctx.fillStyle = TILE_BORDER_COLOR;
            ctx.fill();
            ctx.beginPath();
                ctx.moveTo(TILE_SIZE/2-ARROW_LONG*0.65, -ARROW_WIDE);
                ctx.lineTo(TILE_SIZE/2-ARROW_LONG*0.65, +ARROW_WIDE);
                ctx.lineTo(TILE_SIZE/2-ARROW_LONG*0.65+ARROW_LONG, 0);
                ctx.fillStyle = color;
            ctx.fill();
            ctx.resetTransform();

            ctx.font = TILE_TEXT_SIZE + "px serif";
            ctx.fillStyle = "white";
            const text = ctx.measureText(tile.letter.toUpperCase());

            const xOff = text.actualBoundingBoxLeft - (text.actualBoundingBoxLeft + text.actualBoundingBoxRight) / 2;
            const yOff = text.actualBoundingBoxAscent - (text.actualBoundingBoxAscent + text.actualBoundingBoxDescent) / 2;
            ctx.fillText(tile.letter.toUpperCase(), tile.x + xOff, tile.y + yOff);
        }
    }

    function renderBoard()
    {
        ctx.beginPath();
        ctx.roundRect(boardX, boardY,
                      boardW, boardH,
                      [TILE_RADIUS]);

        ctx.fillStyle = BOARD_COLOR;
        ctx.fill();

        for (let y = 0; y < boardTilesH; y++)
        {
            for (let x = 0; x < boardTilesW; x++)
            {
                const direction = board[y][x].direction;

                if (direction === "x")
                    continue;

                const slotX = boardX + BOARD_PAD + x*(TILE_SIZE+BOARD_PAD) + TILE_SIZE/2;
                const slotY = boardY + BOARD_PAD + y*(TILE_SIZE+BOARD_PAD) + TILE_SIZE/2;

                let connectColour = BOARD_CONNECT_COLOR;
                if (board[y][x].confirmed)
                    connectColour = BOARD_CONFIRMED_COLOR

                const rotateDegrees = {">": 0, "v": 90, "<": 180, "^": 270}[direction]

                const connectionWide = ARROW_WIDE *2;

                ctx.translate(slotX, slotY);
                ctx.rotate(rotateDegrees * Math.PI / 180);
                {
                    if (board[y][x].pointedAtByOtherPos.length === 0)
                    {
                        ctx.beginPath();
                        ctx.arc(-TILE_SIZE / 2 - 1, 0, connectionWide/2, 0, 2 * Math.PI);
                        ctx.fillStyle = connectColour;
                        ctx.fill();
                    }

                    if (board[y][x].pointAt)
                    {
                        ctx.beginPath();
                        ctx.fillStyle = connectColour;
                        ctx.fillRect(TILE_SIZE / 2, -(connectionWide / 2), BOARD_PAD, connectionWide);
                    }
                }
                ctx.resetTransform();

                ctx.beginPath();
                ctx.roundRect(slotX-TILE_SIZE/2, slotY-TILE_SIZE/2, TILE_SIZE, TILE_SIZE, [TILE_RADIUS]);
                ctx.fillStyle = BOARD_SLOT_COLOR;
                ctx.fill();

                ctx.translate(slotX, slotY);
                ctx.rotate(rotateDegrees * Math.PI / 180);
                {
                    ctx.beginPath();
                    ctx.moveTo(TILE_SIZE / 2 - 1, -ARROW_WIDE);
                    ctx.lineTo(TILE_SIZE / 2 - 1, +ARROW_WIDE);
                    ctx.lineTo(TILE_SIZE / 2 + ARROW_LONG - 1, 0);
                    ctx.fillStyle = BOARD_SLOT_COLOR;
                    ctx.fill();
                }
                ctx.resetTransform();
            }
        }
    }

    function confirmTiles()
    {
        for (let y = 0; y < boardTilesH; y++)
        {
            for (let x = 0; x < boardTilesW; x++)
            {
                const boardPos = board[y][x];
                boardPos.confirmed = false;
            }
        }

        for (let y = 0; y < boardTilesH; y++)
        {
            for (let x = 0; x < boardTilesW; x++)
            {
                const boardPos = board[y][x];

                if (boardPos.pointedAtByOtherPos.length !== 0)
                    continue;

                let ok = true;
                {
                    function check(posToCheck)
                    {
                        const solutionItem = solutionBoard[posToCheck.pos[0]][posToCheck.pos[1]];
                        if (!(posToCheck.tile && posToCheck.tile.letter === solutionItem[0] && solutionItem[1]))
                            ok = false;
                    }

                    let current = boardPos;
                    check(current);
                    while (current.pointAt)
                    {
                        current = board[current.pointAt[0]][current.pointAt[1]];
                        check(current);
                    }
                }

                if (ok)
                {
                    let current = boardPos;
                    current.confirmed = true;
                    while (current.pointAt)
                    {
                        current = board[current.pointAt[0]][current.pointAt[1]];
                        current.confirmed = true;
                    }
                }
            }
        }

        let won = true;
        for (let y = 0; y < boardTilesH; y++)
        {
            for (let x = 0; x < boardTilesW; x++)
            {
                const boardPos = board[y][x];

                if (boardPos.direction === 'x')
                    continue;

                if (!boardPos.confirmed)
                {
                    won = false;
                    break;
                }
            }
        }

        if (won)
            alert("WINNER");
    }

    function render()
    {
        ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

        renderBoard();
        renderTiles();

        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);


    function onMouseMove(mouseX, mouseY)
    {
        if (!selectedTile)
            return;

        selectedTile.x = mouseX + selectOffsetX;
        selectedTile.y = mouseY + selectOffsetY;

        snappedBoardPos = null;
        for (let y = 0; y < boardTilesH; y++)
        {
            for (let x = 0; x < boardTilesW; x++)
            {
                const boardPos = board[y][x];

                if (selectedTile.direction !== boardPos.direction || (boardPos.tile !== null && boardPos !== selectedTile))
                    continue;

                const slotX = boardX + BOARD_PAD + x * (TILE_SIZE + BOARD_PAD) + TILE_SIZE / 2;
                const slotY = boardY + BOARD_PAD + y * (TILE_SIZE + BOARD_PAD) + TILE_SIZE / 2;

                let distSqr = (slotX-selectedTile.x)*(slotX-selectedTile.x) + (slotY-selectedTile.y)*(slotY-selectedTile.y);

                if (distSqr < (TILE_SIZE/2)*(TILE_SIZE/2))
                {
                    selectedTile.x = slotX;
                    selectedTile.y = slotY;
                    snappedBoardPos = boardPos;
                }
            }
        }
    }

    gameCanvas.addEventListener('mousemove', (e) =>
    {
        onMouseMove(e.offsetX * window.devicePixelRatio, e.offsetY * window.devicePixelRatio);
    });

    gameCanvas.addEventListener('mousedown', (e) =>
    {
        const mx = e.offsetX * window.devicePixelRatio;
        const my = e.offsetY * window.devicePixelRatio;

        selectedTile = null;
        for (let i = tiles.length-1; i >= 0; i--)
        {
            const tile = tiles[i];

            const l = tile.x-TILE_SIZE/2;
            const r = tile.x+TILE_SIZE/2;
            const t = tile.y-TILE_SIZE/2;
            const b = tile.y+TILE_SIZE/2;

            if (mx >= l && mx <= r && my >= t && my <= b)
            {
                selectedTile = tile;
                if (selectedTile.boardPos)
                {
                    selectedTile.boardPos.tile = null;
                    selectedTile.boardPos = null;
                }
                tiles.splice(i, 1);
                tiles.push(selectedTile);
                selectOffsetX = selectedTile.x - mx;
                selectOffsetY = selectedTile.y - my
                confirmTiles();
                break;
            }
        }

        onMouseMove(mx, my);
    });

    gameCanvas.addEventListener('mouseup', (e) =>
    {
        if (selectedTile)
        {
            selectedTile.boardPos = snappedBoardPos;
            if (snappedBoardPos)
                snappedBoardPos.tile = selectedTile;
        }
        selectedTile = null;
        snappedBoardPos = null;

        confirmTiles();
    });

</script>
</body>
</html>